"""
Batch simulation runner

Wraps functionality to initialise a snapshot
of the simulation environment and then
run the simulation across a sequence of
parameter samples and random seeds.

This batch executor uses joblib to execute
simulation samples in parallel.
"""
import itertools
import typing

import joblib


class BatchRunner:
    """
    Class wrapping simulation sampling functionality

    This class wraps functions used to

    * Initialise a simulation snapshot, i.e. initialise
      the state of the network (either manually deploying
      contracts or by forking a remote chain).
    * Running simulations across parameter samples and
      random seeds, starting from the previously generated
      snapshot.

    Parameters
    ----------
    init_func: typing.Callable
        Function returning an simulation snapshot and
        and any data returned from the initialisation
        (e.g. contract addresses). This function should
        have the signature

        .. code-block:: python

           def init_func(
               *init_args, **init_kwargs
           ) -> (Snapshot, typing.Any):
               ...

        where ``Snapshot`` is the data returned from the
        :py:meth:`verbs.envs.ForkEnv.export_snapshot`
        method of the sim-environment.

    exec_func: typing.Callable
        Simulation execution function, should have the
        signature

        .. code-block:: python

           def exec_func(
               snapshot,
               n_steps: int,
               seed: int,
               env_data: typing.Any,
               **params
           ) -> typing.List[typing.List[typing.Any]]:
               ...

        where the arguments are:

        * ``snapshot`` is the evm snapshot generated by
          ``init_func`` function.
        * ``n_steps`` is the number of simulation steps
        * ``seed`` is the random seed
        * ``env_data`` is data returned by ``init_func``
        * ``params`` keyword parameters
          taken from the parameter samples
    """

    def __init__(
        self,
        init_func: typing.Callable,
        exec_func: typing.Callable,
    ):
        self.init_func = init_func
        self.exec_func = exec_func

    def run(
        self,
        n_steps: int,
        n_samples: int,
        param_samples: typing.List[typing.Dict],
        init_args: typing.Optional[typing.Tuple] = None,
        init_kwargs: typing.Optional[typing.Dict] = None,
        n_jobs=-2,
        verbose=10,
    ) -> typing.List[typing.Dict]:
        """
        Run simulations across parameter samples and seeds

        Notes
        -----
        The batch runner generates ``n_samples`` monte-carlo samples
        for each parameter sample provided, hence in total
        it will run ``len(param_samples) * n_samples`` simulations.

        Parameters
        ----------
        n_steps: int
            Number of simulation steps (i.e. blocks) to run each
            individual simulation for.
        n_samples: int
            Number of random seeds to run for each set of parameters.
        params_samples: typing.List[typing.Dict]
            List of keyword parameter samples, these will be
            individually passed to simulation runs.
        init_args: typing.Tuple, optional
            Optional positional arguments to pass to the initialisation
            function.
        init_kwargs: typing.Dict, optional
            Optional keyword arguments to pass to the initialisation
            function.
        n_jobs: int, optional
            Number of processes to allow joblib to use during parallel
            execution, 1 will turn off multi-threading, and negative
            values are subtracted from the total available processes.
            Default value is -2.
        verbose: int, optional
            Level of logging used by joblib, default 10 (full logging).

        Returns
        -------
        typing.List[typing.Dict]
            List of results generated by each parameter sample. Each
            entry is a dictionary with the keys

            * ``params`` the parameters used to generate these samples.
            * ``samples`` the data returned by from the simulation
              monte-carlo samples.
        """
        init_args = () if init_args is None else init_args
        init_kwargs = dict() if init_kwargs is None else init_kwargs

        snapshot, env_data = self.init_func(*init_args, **init_kwargs)

        n_param_samples = len(param_samples)
        arg_set = itertools.product(param_samples, range(n_samples))

        results = joblib.Parallel(n_jobs=n_jobs, verbose=verbose)(
            joblib.delayed(self.exec_func)(snapshot, n_steps, seed, env_data, **params)
            for params, seed in arg_set
        )

        grouped_results = list()

        for i in range(n_param_samples):
            idx = i * n_samples

            grouped_results.append(
                dict(params=param_samples[i], samples=results[idx : idx + n_samples])
            )

        return grouped_results
