Batch Execution
===============

Typically we might want to execute batches of simulation across
random seeds and parameter samples :py:class:`verbs.sim.batch_runner.BatchRunner`
implements functionality to generate samples in parallel.

A particular use-case is generating an initial snapshot from a remote fork
(which is generally quite slow) and then quickly generate samples from
the local snapshot.

A batch runner is defined by two functions

* An **initialisation function** that generates an initial snapshot of the
  simulation.
* An **execution function** that runs a simulation from the initial snapshot.

From the previous example we might define an initialisation function

.. code-block:: python

   def init_func(*, bytecode, constructor_args):
        env = verbs.EmptyEnv(1234)

        erc20_abi = verbs.abi.get_abi("ERC20", ERC20_ABI)
        erc20_address = erc20_abi.constructor.deploy(
            env, ERC20_BYTECODE, constructor_args
        )
        admin = verbs.utils.int_to_address(99999999)

        return env.export_snapshot(), (erc20_address, admin)

that initialises an empty environment and deploys a contract and admin account, and
returns the snapshot and the addresses of the deployed contract and admin. The
initialisation function can have arbitrary positional and keyword arguments and should
return a tuple containing the initial snapshot and any data that should be passed
to the execution function.

The execution function could then be defined as

.. code-block:: python

    def exec_func(snapshot, n_steps, seed, addresses, *, activation_rate):
        erc20_address, admin_address = addresses
        env = envs.EmptyEnv(seed, snapshot)
        erc20_abi = verbs.abi.get_abi("ERC20", ERC20_ABI)

        agents = [
            Agent(i + 100, erc20_address, erc20_abi, N_AGENTS, activation_rate)
            for i in range(N_AGENTS)
        ]

        erc20_abi.transfer.execute(
            env,
            admin_address,
            erc20_address,
            [agents[0].address, int(1e19)],
        )

        runner = verbs.sim.Sim(101, env, agents)
        results = runner.run(n_steps)
        return results

where the execution function arguments are

* The initial snapshot (i.e. the one generated by the initialisation function)
* The number of simulation steps/blocks
* A random seed
* The values returned from the initialisation function (here the contract address)
* Keyword parameter arguments, which will be passed through by the batch
  runner, in this case we are passing the activation rate to the agents

The batch-runner will generate sample and random seed combinations, and
execute simulation across these combinations in parallel

.. code-block:: python

   b = batch_runner.BatchRunner(init_func, exec_func)

   batch_results = b.run(
        100,
        10,
        [dict(activation_rate=0.1), dict(activation_rate=0.2)],
        init_kwargs=dict(bytecode=bytecode, constructor_args=[int(1e19)]),
        n_jobs=-1,
    )

The parameter set to sample across is provided as a list of dictionaries.
The batch-runner will then generate 20 samples (2 parameter sets x 10 random seeds)
each for 100 steps.
